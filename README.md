# Year 2038 Timer

# What is it?

The  **Year 2038 problem**  (also known as  **Y2038**,[](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-:0-1)  **Y2K38**, or the  **Epochalypse**[](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-2)[[3]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-3)) is a  [time formatting bug](https://en.wikipedia.org/wiki/Time_formatting_and_storage_bugs "Time formatting and storage bugs")  in computer systems with representing times after 03:14:07  [UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time "Coordinated Universal Time")  on 19 January 2038.

The problem exists in systems which measure  [Unix time](https://en.wikipedia.org/wiki/Unix_time "Unix time")  — the number of seconds elapsed since the  _Unix epoch_  (00:00:00 UTC on 1 January 1970) — and store it in a  [signed 32-bit integer](https://en.wikipedia.org/wiki/Integer_(computer_science) "Integer (computer science)"). The data type is only capable of representing integers between −(231) and  [231  − 1](https://en.wikipedia.org/wiki/2,147,483,647 "2,147,483,647"), meaning the latest time that can be properly encoded is 231  − 1 seconds after epoch (03:14:07 UTC on 19 January 2038). Attempting to increment to the following second (03:14:08) will cause the  [integer to overflow](https://en.wikipedia.org/wiki/Integer_overflow "Integer overflow"), setting its value to −(231) which systems will interpret as 231  seconds  _before_  epoch (20:45:52 UTC on 13 December 1901). The problem is similar in nature to the  [Year 2000 problem](https://en.wikipedia.org/wiki/Year_2000_problem "Year 2000 problem").

Computer systems that use time for critical computations may encounter fatal errors if the Y2038 problem is not addressed. Some applications that use future dates have already encountered the bug. The most vulnerable systems are those which are infrequently or never updated, such as  [legacy](https://en.wikipedia.org/wiki/Legacy_system "Legacy system")  and  [embedded systems](https://en.wikipedia.org/wiki/Embedded_system "Embedded system"). There is no universal solution to the problem, though many modern systems have been upgraded to measure Unix time with signed  [64-bit](https://en.wikipedia.org/wiki/64-bit_computing "64-bit computing")  integers which will not overflow for 292 billion years.

## Cause
Many computer systems measure time and date as  [Unix time](https://en.wikipedia.org/wiki/Unix_time "Unix time"), an international standard for digital timekeeping. Unix time is defined as the number of seconds elapsed since 00:00:00  [UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time "Coordinated Universal Time")  on 1 January 1970 (an arbitrarily chosen time), which has been dubbed the  _Unix epoch_.

Unix time has historically been encoded as a  [signed 32-bit integer](https://en.wikipedia.org/wiki/Integer_(computer_science) "Integer (computer science)"), a data type composed of 32  [binary digits](https://en.wikipedia.org/wiki/Bit "Bit")  (bits) which represent an integer value, with 'signed' meaning that one bit is reserved to indicate  [sign](https://en.wikipedia.org/wiki/Sign_(mathematics) "Sign (mathematics)")  (+/–). Thus, a signed 32-bit integer can only represent integer values from −(231) to  [231  − 1](https://en.wikipedia.org/wiki/2,147,483,647 "2,147,483,647")  inclusive. Consequently, if a signed 32-bit integer is used to store Unix time, the latest time that can be stored is 231  − 1 (2,147,483,647) seconds after epoch, which is 03:14:07 on Tuesday, 19 January 2038.[[4]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-spinellis-4)  Systems that attempt to increment this value by one more second to 231  seconds after epoch (03:14:08) will suffer  [integer overflow](https://en.wikipedia.org/wiki/Integer_overflow "Integer overflow"), inadvertently flipping the sign bit to indicate a negative number. This changes the integer value to −(231), or 231  seconds  _before_  epoch rather than  _after_, which systems will interpret as 20:45:52 on Friday, 13 December 1901. From here, systems will continue to count up, towards zero, and then up through the positive integers again. As many computer systems use time computations to run critical functions, the bug may introduce fatal errors.

## Vulnerable systems
Any system using  [data structures](https://en.wikipedia.org/wiki/Data_structure "Data structure")  with 32-bit time representations has an inherent risk to fail. A full list of these data structures is virtually impossible to derive, but there are well-known data structures that have the Unix time problem:

-   File systems (many file systems use only 32 bits to represent times in  [inodes](https://en.wikipedia.org/wiki/Inode "Inode"))
-   Binary file formats (that use 32-bit time fields)
-   Databases (that have 32-bit time fields)
-   Database query languages, like  [SQL](https://en.wikipedia.org/wiki/SQL "SQL")  that have  `UNIX_TIMESTAMP()`-like commands
### Embedded systems
[Embedded systems](https://en.wikipedia.org/wiki/Embedded_systems "Embedded systems")  that use dates for either computation or diagnostic logging are most likely to be affected by the Y2038 problem.[[1]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-:0-1)  Despite the modern  [18–24 month generational update in computer systems technology](https://en.wikipedia.org/wiki/Moore%27s_law "Moore's law"), embedded systems are designed to last the lifetime of the machine in which they are a component. It is conceivable that some of these systems may still be in use in 2038. It may be impractical or, in some cases, impossible to upgrade the software running these systems, ultimately requiring replacement if the 32-bit limitations are to be corrected.

Many transportation systems from flight to automobiles use embedded systems extensively. In automotive systems, this may include  [anti-lock braking system](https://en.wikipedia.org/wiki/Anti-lock_braking_system "Anti-lock braking system")  (ABS),  [electronic stability control](https://en.wikipedia.org/wiki/Electronic_stability_control "Electronic stability control")  (ESC/ESP),  [traction control](https://en.wikipedia.org/wiki/Traction_control_system "Traction control system")  (TCS) and automatic  [four-wheel drive](https://en.wikipedia.org/wiki/Four-wheel_drive "Four-wheel drive"); aircraft may use  [inertial guidance systems](https://en.wikipedia.org/wiki/Inertial_navigation_system "Inertial navigation system")  and  [GPS receivers](https://en.wikipedia.org/wiki/Satellite_navigation_device "Satellite navigation device").[[note 1]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-5)  Another major use of embedded systems is in communications devices, including cell phones and Internet-enabled appliances ( e.g.  [routers](https://en.wikipedia.org/wiki/Router_(computing) "Router (computing)"),  [wireless access points](https://en.wikipedia.org/wiki/Wireless_access_point "Wireless access point"),  [IP cameras](https://en.wikipedia.org/wiki/IP_camera "IP camera")) which rely on storing an accurate time and date and are increasingly based on Unix-like operating systems. For example, the Y2038 problem makes some devices running 32-bit  [Android](https://en.wikipedia.org/wiki/Android_(operating_system) "Android (operating system)")  crash and not restart when the time is changed to that date.[[5]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-6)

However, this does not imply that all embedded systems will suffer from the Y2038 problem, since many such systems do not require access to dates. For those that do, those systems which only track the difference between times/dates and not absolute times/dates will, by the nature of the calculation, not experience a major problem. This is the case for automotive diagnostics based on legislated standards such as CARB ([California Air Resources Board](https://en.wikipedia.org/wiki/California_Air_Resources_Board "California Air Resources Board")).[[6]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-7)

## Early problems

In May 2006, reports surfaced of an early manifestation of the Y2038 problem in the  [AOLserver](https://en.wikipedia.org/wiki/AOLserver "AOLserver")  software. The software was designed with a  [kludge](https://en.wikipedia.org/wiki/Kludge "Kludge")  to handle a database request that should "never" time out. Rather than specifically handling this special case, the initial design simply specified an arbitrary  [time-out](https://en.wikipedia.org/wiki/Timeout_(computing) "Timeout (computing)")  date in the future. The default configuration for the server specified that the request should time out after one billion seconds. One billion seconds (approximately 32 years) after 01:27:28 UTC on 13 May 2006 is beyond the 2038 cutoff date. Thus, after this time, the time-out calculation overflowed and returned a date that was actually in the past, causing the software to crash. When the problem was discovered, AOLServer operators had to edit the configuration file and set the time-out to a lower value.[[7]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-8)[[8]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-9)

Players of games or apps which are programmed to impose waiting periods[[9]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-10)  are running into this problem when the players try to bypass the waiting period by setting the date on their devices to a date past 19 January 2038, but are unable to do so, since a 32-bit Unix time format is being used.

## Solutions
There is no universal solution for the Year 2038 problem. For example, in the  [C language](https://en.wikipedia.org/wiki/C_language "C language"), any change to the definition of the  `[time_t](https://en.wikipedia.org/wiki/Time_t "Time t")`  data type would result in  [code-compatibility](https://en.wikipedia.org/wiki/Binary-code_compatibility "Binary-code compatibility")  problems in any application in which date and time representations are dependent on the nature of the signed 32-bit  `time_t`  integer. For example, changing  `time_t`  to an unsigned 32-bit integer, which would extend the range to 2106 (specifically, 06:28:15 UTC on Sunday, 7 February 2106), would adversely affect programs that store, retrieve, or manipulate dates prior to 1970, as such dates are represented by negative numbers. Increasing the size of the  `time_t`  type to 64 bits in an existing system would cause incompatible changes to the layout of structures and the binary interface of functions.

Most operating systems designed to run on 64-bit  [hardware](https://en.wikipedia.org/wiki/Hardware_architecture "Hardware architecture")  already use signed 64-bit  `time_t`  integers. Using a signed 64-bit value introduces a new wraparound date that is over twenty times greater than the estimated  [age of the universe](https://en.wikipedia.org/wiki/Age_of_the_universe "Age of the universe"): approximately 292 billion years from now. The ability to make  [computations](https://en.wikipedia.org/wiki/Computation "Computation")  on dates is limited by the fact that  `tm_year`  uses a signed 32-bit integer value starting at 1900 for the year. This limits the year to a maximum of 2,147,485,547 (2,147,483,647 + 1900).[[10]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-11)

Alternative proposals have been made (some of which are already in use), such as storing either  [milliseconds](https://en.wikipedia.org/wiki/Millisecond "Millisecond")  or  [microseconds](https://en.wikipedia.org/wiki/Microsecond "Microsecond")  since an epoch (typically either 1 January 1970 or 1 January 2000) in a signed 64-bit integer, providing a minimum range of 300,000 years at microsecond resolution.[[11]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-12)[[12]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-13)  In particular, Java's use of 64-bit long integers everywhere to represent time as "milliseconds since 1 January 1970" will work correctly for the next 292 billion years. Other proposals for new time representations provide different precisions, ranges, and sizes (almost always wider than 32 bits), as well as solving other related problems, such as the handling of  [leap seconds](https://en.wikipedia.org/wiki/Leap_second "Leap second"). In particular, TAI64[[13]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-14)  is an implementation of the  [International Atomic Time](https://en.wikipedia.org/wiki/International_Atomic_Time "International Atomic Time")  (TAI) standard, the current international real-time standard for defining a second and frame of reference.

### Implemented solutions
-   [Linux](https://en.wikipedia.org/wiki/Linux "Linux")  originally used a 64-bit  `time_t`  for 64-bit architectures only; the pure 32-bit  [ABI](https://en.wikipedia.org/wiki/Application_binary_interface "Application binary interface")  was not changed due to backward compatibility.[[14]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-Pondering2038-15)  Starting with version  [5.6](https://en.wikipedia.org/wiki/Linux_kernel_version_history#Releases_5.x.y "Linux kernel version history"), 64-bit  `time_t`  is supported on 32-bit architectures, too. This was done primarily for the sake of  [embedded Linux](https://en.wikipedia.org/wiki/Linux_on_embedded_systems "Linux on embedded systems")  systems.[[15]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-16)
-   Starting with  [NetBSD](https://en.wikipedia.org/wiki/NetBSD "NetBSD")  version 6.0 (released in October 2012), the NetBSD operating system uses a 64-bit  `time_t`  for both 32-bit and 64-bit architectures. Applications that were compiled for an older NetBSD release with 32-bit  `time_t`  are supported via a binary compatibility layer, but such older applications will still suffer from the Y2038 problem.[[16]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-17)
-   [OpenBSD](https://en.wikipedia.org/wiki/OpenBSD "OpenBSD")  since version 5.5, released in May 2014, also uses a 64-bit  `time_t`  for both 32-bit and 64-bit architectures. In contrast to  [NetBSD](https://en.wikipedia.org/wiki/NetBSD "NetBSD"), there is no binary compatibility layer. Therefore, applications expecting a 32-bit  `time_t`  and applications using anything different from  `time_t`  to store time values may break.[[17]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-18)
-   [FreeBSD](https://en.wikipedia.org/wiki/FreeBSD "FreeBSD")  uses 64-bit  `time_t`  for all 32-bit and 64-bit architectures except 32-bit i386, which uses signed 32-bit  `time_t`  instead.[[18]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-19)
-   The  [x32 ABI](https://en.wikipedia.org/wiki/X32_ABI "X32 ABI")  for Linux (which defines an environment for programs with 32-bit addresses but running the processor in 64-bit mode) uses a 64-bit  `time_t`. Since it was a new environment, there was no need for special compatibility precautions.[[14]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-Pondering2038-15)
-   [Network File System](https://en.wikipedia.org/wiki/Network_File_System "Network File System")  version 4 has defined its time fields as  `struct nfstime4 {int64_t seconds; uint32_t nseconds;}`  since December 2000.[[19]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-20)  Values greater than zero for the seconds field denote dates after the 0-hour, January 1, 1970. Values less than zero for the seconds field denote dates before the 0-hour, January 1, 1970. In both cases, the nseconds (nanoseconds) field is to be added to the seconds field for the final time representation.
-   While the native APIs of  [OpenVMS](https://en.wikipedia.org/wiki/OpenVMS "OpenVMS")  can support timestamps up to the 31st of July 31086,[[20]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-Crazy_time,_Stanford,_1997-21)  the C runtime library (CRTL) uses 32-bit integers for  `time_t`.[[21]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-vsi-c-rtl-22)  As part of Y2K compliance work that was carried out in 1998, the CRTL was modified to use unsigned 32-bit integers to represent time; extending the range of  `time_t`  up to the 7th of February 2106.[[22]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-23)
-   As of  [MySQL](https://en.wikipedia.org/wiki/MySQL "MySQL")  8.0.28, the functions  `FROM_UNIXTIME()`,  `UNIX_TIMESTAMP()`, and  `CONVERT_TZ()`  handle 64-bit values on platforms that support them. This includes 64-bit versions of Linux, MacOS, and Windows.[[23]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-24)  In relational database versions prior to August 2021, built-in functions like  `UNIX_TIMESTAMP()`  will return 0 after 03:14:07  [UTC](https://en.wikipedia.org/wiki/UTC "UTC")  on 19 January 2038.[[24]](https://en.wikipedia.org/wiki/Year_2038_problem#cite_note-25)

